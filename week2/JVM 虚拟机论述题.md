# 作业题：JVM 虚拟机论述

## 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）



jvm虚拟机通过编译后的.class文件,会进入类加载子系统,把字节码转入到运行时数据区中.

#### 运行时数据区(内存结构)

##### 堆

虚拟机所管理内存中最大且最重要的一块。对于堆的清理有分代假说理论，GC算法也是基于此（细节下面会重点描述）。

堆内存分为新生代、老年代、永久代（1.8后删除，改为元空间，使用的直接内存）、Eden、Survivor。

##### 虚拟机栈

虚拟机栈是线程私有的，它的生命周期与线程相同，栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。可以通过-Xss 修改大小。



##### 本地方法栈

本地方法栈是虚拟机使用到的本地（用 C++ 写的 native 方法）方法。



##### 方法区（元空间）

存放已被虚拟机加载的类相关信息，包含运行时常量池、字符串常量池、类基本信息等。

在JDK 1.8移除了永久代，方法区通过元空间的方式实现。



###### 运行时常量池

是方法区的一部分，包含方法引用、类引用、支付穿值、字面量等。

###### 字符串常量池

双引号String 对象会自动放入常量池

调用String的intern 方法也会将对象放入到常量池中

###### 类基本信息

当java文件被编译成class文件之后，就会生成class常量池，主要存放两大类常量：字面量和符号引用



##### 程序计数器

线程是一个个的顺序执行流，CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行，JVM就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

通过javap 可以看到 java所有的操作指令，可以根据官方发布的操作码来解读每一行代码的执行流程。



##### 其它

###### 直接内存

直接内存是使用 Native 函数库直接分配堆外内存，直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存的限制。如果分配不当，扩展时会出现OutOfMemoryError异常。



#### 为什么堆内存要分年轻代和老年代？

为了提高效率，寿命长的放在一个区，寿命短的放在另一个区，寿命短的区清理频次高一点，寿命长的区清理频次低一点。分代假说的理论是基于GC算法进行设计的。

- 弱分代假说：绝大多数对象都是朝生夕灭的。
- 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。



##### 新生代

大部分的对象都是在新生代的Eden区创建。

##### 老年代

对于一些大对象或者多次GC后还存在的对象会存储在老年代。

###### 晋升方式

在Eden区域之后每经历一次垃圾回收如果存活下来了那么对象的年龄也就增加一，当对象年龄增加到15之后晋升老年代。

新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半，内存不足时也会动态晋升。

minor gc之后，Survivor区空间不足也会晋升老年代。

当创建大对象时会直接晋升老年代。



##### GC算法

###### 复制

适用于新生代



###### 标记清除 

为每个对象存储一个标记，检查对象是否死亡，对于已经死亡的对象进行清除。

会产生内存碎片。

适用于老年代



###### 标记整理

适用于老年代



## 题目 02- 描述一个 Java 对象的生命周期

##### 解释一个对象的创建过程

JVM 执行到 字节码 new 指令时，首先会到常量池查找类是否加载，如果类没有被被加载，就必须先执行加载过程。

如果已经加载则为对象分配内存空间，分配的方式有指针碰撞和空闲列表。

之后会将分配到的内存空间初始化零值（不包括对象头）

然后为对象进行必要的设置，对象头，类的元数据信息，对象的哈希码，对象的 GC 分代年龄等。

最好执行构造方法，完成创建。



##### 解释一个对象的内存分配

大多数情况下，对象在新生代中 Eden 区分配，如果放得下进入新生代，如果放不下则进行youngGC，再次进行分配是否放得下，如果还不行则晋升老年代，此时进行老年代的分配是否存放的下，无法存放则进行FullGC，当3次FullGC以后还是无法存放，则直接OOM。



基于逃逸分析的优化：JVM通过逃逸分析确定该对象不会被外部访问。如果不会逃逸，可以优化对象内存分配位置，通过标量替换优先分配在栈上(栈上分配)。

极客时间专栏《深入拆解 Java 虚拟机》

##### 解释一个对象的销毁过程

当对象不再被使用时，由垃圾回收机制GC自动回收。

##### 对象的 2 种访问方式是什么

通过句柄访问对象

通过直接指针访问对象



##### 为什么需要内存担保

大量对象在GC后仍然存活，Survivor无法容纳新对象，此时会把对象放到老年代，如果不这么做，系统会OOM，影响系统的正常使用，如果没有这种机制，则需要把新生代设置比例更高，这与设计分代理论的初衷不符。





## 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

##### ParNew

新生代并行GC，Serial的多线程版本，配合老年代CMS使用，适用于多核CPU场景，使用复制算法。

##### ParallelScavenge

新生代并行GC，吞吐量优先的收集器，新生代使用并行收集器，使用复制算法。

##### ParallelOld

老年代并行GC，标记整理算法，多线程收集垃圾，配合ParallelScavenge使用。

##### CMS

老年代并行GC，标记清除算法，高吞吐量。在初始标记、并发清理、重新标记的时候会发生STW，其余世界并发进行。

##### G1 

新时代GC，全局使用标记整理，局部复制算法与CMS同样的STW。全新的内存划分方式，将内存空间分成若干小区域，每次收集只收集几个区域，可设置垃圾清理时间(预估值)，适用于4G以上内存环境，最低2G，否则无法发挥作用。JDK 8可设置，11默认。

##### ZGC

G1增强版本，标记整理算法，新增负载屏障等功能，建议JDK17使用。

