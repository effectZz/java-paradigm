# 题目 01：

一条 SQL 语句在 MySQL 中是如何执行的？

![mysql](.\mysql.png)



![执行过程](.\执行过程.png)



通过架构图可以看出主要分为三部分，分别是：客户端、server层和存储引擎。



**1、连接器**

连接器位于Server层，作用是负责跟所有客户端的连接进行交互，并对连接进行鉴权管理连接等。

**2、缓存查询**

当连接建立成功后，select语句就会先来到缓存查询这一块，尝试从缓存中拿到数据。

如果没拿到结果则会继续走后面的流程拿到数据返回。

**3、分析器**

分析器首先会进行词法分析与语法分析，把输入的语句拆分。

**4、优化器**

优化器是在表里面有多个索引决定使用哪个索引，或者多表关联join的时候，是先执行哪一个逻辑等做一系列的处理。

**5、执行引擎**

执行器就会根据表的引擎定义，去使用这个引擎提供的接口。



# 题目 02

请解释一下你理解的事务是什么？
 要点：

1. 事务四大特性 ACID
   - 原子性：事务中的操作要么全部成功，要么全部失败。
   - 一致性：在事务开始之前和事务结束以后，数据库的完整性不会被破坏。
   - 隔离性：一个事务的执行不能其它的事务所干扰。
   - 持久性：事务结束后，对数据的修改就是永久的。
2. 事务隔离级别
   - 读未提交（Read uncommitted）：一个事务可以读取另一个未提交事务的数据。
   - 读已提交（Read committed）：在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的同一sql在其他事务执行前后返回的是不同的结果。
   - 可重复读（Repeatable read）：在事务开启时，不再允许其它事务修改操作，所以每次读取数据是一样的。
   - 串行化（Serializable）：相当于对数据加了独占锁，性能效率低下。
3. 事务会产生的并发问题
   - 脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
   - 不可重复读：一个事务先后读取同一条记录，而事务在两次读取之间被其它事务修改了，两次读取的数据不同。
   - 幻读/虚读：第一个事务对一个表中的数据进行了修改，第二个事务也修改这个表中的数据，比如新增。那么第一个事务会发现表中还存在没有修改的数据。
4. 事务的安全性、性能与隔离级别的关系

| 隔离级别     | 脏读 | 不可重复读 | 幻读 |
| ------------ | ---- | ---------- | ---- |
| **读未提交** | √    | √          | √    |
| **读已提交** | ×    | √          | √    |
| **可重复读** | ×    | ×          | √    |
| **串行化**   | ×    | ×          | ×    |

