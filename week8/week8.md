## 题目 01- 请你说一说 MySQL 的锁机制

要求：

- 按照锁的粒度，锁的功能来分析

按照锁功能分:共享锁(读S锁)和排它锁(写X锁)

按照锁的粒度:全局锁、表级锁、行级锁

全局锁：对整个数据库实例加锁，加锁后处于只读状态，事务提交语句都将被阻塞。

表级锁：

1. 表读写锁
2. 元数据锁 MDL：当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁 ，MDL的作用是，保证读写的正确性
3. 意向锁：意向锁的主要作用是为了【全表更新数据】时的性能提升
4. 自增锁：一种特殊的表级锁，发生涉及AUTO_INCREMENT列的事务性插入操作时产生



![兼容](.\兼容.png)

>
>
>意向锁相互兼容，因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作
>
>因为上了表级S锁后，不允许其他事务再加X锁，所以表级S锁和X、IX锁不兼容
>
>上了表级X锁后，会修改数据，所以表级X锁和 IS、IX、S、X（即使是行排他锁，因为表级锁定的行肯定包括行级速订的行，所以表级X和IX、行级X）不兼容
>
>上了行级X锁后，行级X锁不会因为有别的事务上了IX而堵塞，一个mysql是允许多个行级X锁同时存在的，只要他们不是针对相同的数据行



行级锁：myisam只有记录锁

InnoDB分为四种

1. 记录锁：锁定索引中一条记录
2. 间隙锁：要么锁住索引记录中间的值，要么锁住第一个索引记录前面的值或者最后一个索引记录后面的值
3. 临键锁：是索引记录上的记录锁和在索引记录之前的间隙锁的组合（间隙锁+记录锁）(左开右闭]
4. 插入意向锁：做insert操作时添加的对记录id的锁



- 什么是死锁，为什么会发生，如何排查？

死锁是多个线程在执行过程中， 因争夺资源而造成的相互等待的现象。
死锁产生的4个必要条件：互斥条件 、请求和保留条件 、不剥夺条件 、环路等待条件

死锁的发生与否，并不在于事务中有多少条SQL语句，【死锁的关键在于】：两个(或以上)的Session【加锁的顺序】不一致。



解决方案：

一是超时机制 即两个事务相互等待时，一旦等待时间超过一个阈值，那么超时事务回滚释放资源，另一个事务就能正常执行了。
在InnoDB存储引擎中，参数innodb lock_wait timeout 用来设置事务超时的时间



- 行锁是通过加在什么上完成的锁定？

通过对索引上的索引项加锁来实现行锁，如果是辅助索引需要回表。



- 详细说说这条 SQL 的锁定情况：`delete from tt where uid = 666`;

需要知道uid的实际情况，比如是否有索引，如果有是否为主键或者唯一索引。

下面是对几种情况的描述：

如果是唯一索引：

当查询的记录是存在的，将该记录的索引中的临键锁会退化成记录锁。
当查询的记录是不存在的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的临键锁会退化成间隙锁。



如果是非唯一索引：

当查询的记录存在时，扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是临键锁，而对于第一个不符合条件的索引记录，该索引的临键锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。

当查询的记录不存在时，扫描到第一条不符合条件的二级索引记录，该二级索引的临键锁会退化成间隙锁。不会对主键索引加锁。



如果没用索引：

每一条记录的索引上都会加临键锁，这样就相当于锁住的全表





## 题目 02- 请你说一说 MySQL 的 SQL 优化

SQL优化：

对于开发人员来讲主要就算查询语句的优化，首先可使用Explain 命令，查询SQL的执行状况，根据显示的结果进行优化语句。

Explain包含以下主要字段：
select_type：表示单位查询的查询类型，比如：普通查询、联合查询、子查询等复杂查询。
type：表示表的连接类型。
possible_keys：此次查询中可能选用的索引
key：查询真正使用到的索引
key_len：显示MySQL决定使用的索引size
ref：哪个字段或常数与 key 一起被使用
rows：显示此查询一共扫描了多少行，这个是一个估计值，不是精确的值。
Extra：额外信息



查询字段尽量不要 `*` ，尽量单独写所需要的字段或者索引字段。

如果预计SELECT语句的查询结果是一条，最好使用 LIMIT 1，可以停止全表扫描。

单表分页时，使用自增主键排序之后，先使用where条件 id > offset值，limit后面只写rows。

尽量使用连接查询（JOIN）代替子查询，连接查询时不需要建立临时表，其速度比子查询快。



关联查询时候需要小表驱动大表。

> SQL优化实战中的三个方式：慢查询日志 --> explain --> show profile



数据库设计优化：

1. 将字段很多的表分解成多个表（分表）
2. 增加中间表
3. 增加冗余字段



索引优化：

1. 表记录很少不需创建索引：存储的开销。
2. 一个表的索引个数不能过多：浪费空间，占据大量的磁盘空间。
3. 频繁更新的字段不建议作为索引：频繁更新的字段引发频繁的页分裂和页合并。
4. 区分度低的字段，不建议建索引：比如性别，男，女；比如状态，区分度太低。
5. 在InnoDB存储引擎中，主键索引建议使用自增的长整型，避免使用很长的字段：自增id提高查询效率，id过长会页的可存储的数据量。
6. 不建议用无序的值作为索引：例如身份证、UUID。
7. 尽量创建组合索引，而不是单列索引：节省空间，有可能会变成覆盖索引。





数据库配置优化：

连接数max_connections

线程thread_cache_size

缓冲区innodb_buffer_pool_size：物理内存的50%~80%

脏页innodb_max_dirty_pages_pct：推荐值为25%~50%

最大IO性能指标innodb_io_capacity：默认200，如果SSD，调整为5000~20000

日志组redo：默认48MB，日志文件越大越节省磁盘IO，要注意日
志文件变大会增加崩溃恢复时间

redo lo策略innodb_flush_log_at_trx_commit



```
# 01-缓冲区，将数据保存在内存中，保证从内存读取数据。推荐值为总物理内存的50%~80%。
innodb_buffer_pool_size=
# 02-日志组（Redo）中每个日志文件的大小，默认48MB，日志文件越大越节省磁盘IO，但需要注意
日志文件变大增加崩溃恢复时间
innodb_log_file_size=48
# 03-用来控制Redo日志刷新到磁盘的策略。
innodb_flush_log_at_trx_commit=1
# 04-每提交1次事务同步写到磁盘中，可以设置为n。
sync_binlog=1
# 05-脏页占innodb_buffer_pool_size的比例时，触发刷脏页到磁盘。推荐值为25%~50%。
innodb_max_dirty_pages_pct=30
# 06-后台进程最大IO性能指标。默认200，如果SSD，调整为5000~20000
innodb_io_capacity=200
# 07-指定innodb共享表空间文件及大小。
innodb_data_file_path=
# 08-慢查询日志的阈值设置，单位秒。
long_qurey_time=3
# 09-MySQL的binlog复制的形式，MySQL8.0默认为row
binlog_format=row
# 10-同时连接客户端的最大数量
max_connections=200
# 11-全量日志建议关闭。默认关闭
general_log=0
```

